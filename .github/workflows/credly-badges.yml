name: Credly Badges

on:
  workflow_dispatch:
  schedule:
    - cron: '0 7 * * *'

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Create updater script
        run: |
          cat > credly_update.py << 'PY'
          import json, re, datetime, html, os, hashlib, mimetypes
          from pathlib import Path
          from urllib.request import Request, urlopen
          from urllib.error import HTTPError, URLError

          BASE = "https://www.credly.com/users/jason-gardner.a0afe0ad/badges.json"
          UA = "Mozilla/5.0 (GitHubActions Credly Fetcher)"

          def fetch_all():
              items = []
              for page in range(1, 51):
                  url = f"{BASE}?page={page}"
                  try:
                      req = Request(url, headers={"User-Agent": UA})
                      with urlopen(req, timeout=30) as resp:
                          data = json.loads(resp.read().decode("utf-8"))
                  except (HTTPError, URLError):
                      break
                  badges = data if isinstance(data, list) else (data.get("data") or data.get("badges") or [])
                  if not badges:
                      break
                  items.extend(badges)
              return items

          def get(d, *ks, default=None):
              cur = d
              for k in ks:
                  if not isinstance(cur, dict):
                      return default
                  cur = cur.get(k)
              return default if cur is None else cur

          def normalize_img(url: str) -> str:
              if not url:
                  return url
              return re.sub(r"/size/\d+x\d+/", "/size/110x110/", url)

          def safe_name(s: str) -> str:
              s = re.sub(r"[^A-Za-z0-9._-]+", "_", s).strip("_")
              return s or "badge"

          def download_image(url: str, dest_dir: Path) -> str:
              """Download image, return relative path like 'badges/<file>'."""
              dest_dir.mkdir(parents=True, exist_ok=True)
              # Use a stable filename: <sanitized-name>-<sha8>.<ext>
              # Weâ€™ll infer ext from content-type if possible.
              h = hashlib.sha1(url.encode("utf-8")).hexdigest()[:8]
              # Guess ext from URL; may be .png or .jpg
              ext = os.path.splitext(url.split("?")[0])[1].lower()
              if ext not in [".png", ".jpg", ".jpeg", ".webp", ".gif"]:
                  ext = ".png"
              # Temp filename first
              tmp_path = dest_dir / f"tmp-{h}{ext}"
              final_path = dest_dir / f"{h}{ext}"

              req = Request(url, headers={"User-Agent": UA})
              with urlopen(req, timeout=30) as resp:
                  data = resp.read()
                  ctype = resp.headers.get("Content-Type","").lower()
              # If content-type implies a different ext, fix it
              if "jpeg" in ctype and ext not in [".jpg", ".jpeg"]:
                  final_path = dest_dir / f"{h}.jpg"
              elif "png" in ctype and ext != ".png":
                  final_path = dest_dir / f"{h}.png"
              elif "webp" in ctype and ext != ".webp":
                  final_path = dest_dir / f"{h}.webp"

              tmp_path.write_bytes(data)
              if final_path.exists():
                  # If identical, keep existing; else overwrite
                  if final_path.read_bytes() != data:
                      final_path.write_bytes(data)
                  tmp_path.unlink(missing_ok=True)
              else:
                  tmp_path.replace(final_path)

              return f"badges/{final_path.name}"

          raw = fetch_all()
          items = []
          for b in raw:
              issued = get(b, "issued_at") or get(b, "issued_at_date") or get(b, "created_at") or ""
              try:
                  dt = datetime.datetime.fromisoformat(issued.replace("Z", "+00:00"))
              except Exception:
                  dt = datetime.datetime.min

              img  = get(b, "image_url") or get(b, "badge_template", "image_url")
              img  = normalize_img(img)

              link = (get(b, "url") or get(b, "share_url") or get(b, "public_url")
                      or get(b, "path") or get(b, "badge_url")
                      or get(b, "badge_template", "url") or get(b, "badge_template", "public_url"))
              if link and link.startswith("/"):
                  link = "https://www.credly.com" + link

              name = get(b, "name") or get(b, "badge_template", "name") or "Badge"

              if link and img:
                  items.append({"dt": dt, "link": link, "img": img, "name": name})

          # newest first, de-dupe by link
          items.sort(key=lambda x: x["dt"], reverse=True)
          seen, uniq = set(), []
          for it in items:
              if it["link"] in seen:
                  continue
              seen.add(it["link"])
              uniq.append(it)

          # Download images and switch to local paths
          out_dir = Path("badges")
          cells = []
          for it in uniq:
              local = download_image(it["img"], out_dir)
              alt = html.escape(it["name"], quote=True)
              # local relative path prevents camo proxying
              cells.append(f'<a href="{it["link"]}"><img src="{local}" alt="{alt}" height="88"></a>')

          html_block = "<p align=\"left\">\n  " + "\n  ".join(cells) + "\n</p>\n"

          rp = Path("README.md")
          readme = rp.read_text(encoding="utf-8")
          pattern = re.compile(r'(<!--START_SECTION:badges-->)([\s\S]*?)(<!--END_SECTION:badges-->)', re.S)
          if pattern.search(readme):
              new = pattern.sub(r'\1\n' + html_block + r'\3', readme)
          else:
              new = readme.rstrip() + "\n\n## Verified badges\n<!--START_SECTION:badges-->\n" + html_block + "<!--END_SECTION:badges-->\n"
          rp.write_text(new, encoding="utf-8")
          print(f"Rendered {len(cells)} badges (local images).")
          PY

      - name: Run updater
        run: python3 credly_update.py

      - name: Commit changes (if any)
        run: |
          # Add README and any new/changed images
          git add README.md badges || true
          if git diff --cached --quiet; then
            echo "No README or image changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit -m "chore: update Credly badges (local images to avoid camo)"
          git push
